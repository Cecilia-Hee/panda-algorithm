# 括号生成

> [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

## 递归解法

1. 某一次递归终止时需要将当前字符存入数组
2. 字符任取一个位置左侧必 左括号>=右括号
3. 每次递归除了需要传当前字符还需要记情当前左右括号数

```js
var generateParenthesis = function(n) {
  let res = [];
  function help(cur, left, right) {
    if(cur.length === 2*n) {
      res.push(cur)
      return;
    }

    if(left < n) {
      help(cur+'(', left+1, right)
    }
    if(right < left) {
      help(cur+')', left, right +1)
    }
  }
  help('', 0, 0)
  return res;
};
```

## 动态规划

dp的要解：

- 第 n 步 要像前几步转换 如 f3 = f1/f2/f1,f2 ------------------------ 注意
- f(0)：""
- f(1)："()" == "("+f(0)+")" == "("f(0)")" --------------------------- 注意
- f(2)：
  - "()()" == "("+f(0)+")" + "(" + ")" == "("+f(0)+")" + f(1)
  == "(f(0)")"f(1)
  - "(())"
  == "(" + f(1) +")"
  == "("f(1)")" 
- f(3)：
  -  "((()))" && f(2) == "(())" 时
  == "(" + f(2) + ")" == "("f(2)")"
  - "(()())" && f(2) == "()()" 时
  == "(" + f(2) + ")" == "("f(2)")"
  - "(())()" && f(2) == "(())" 时
  == f(2) + "(" + ")"
  == f(2)"("f(0)") 
  - "()(())" 同理如上
  == "("f(0)")f(2)
  - "()()()" && f(2) == "()()" 时
  == f(1) + f(2)
  == f(1) + "(" + "f(1)" +")"
  == f(1)"("f(1))" 

---
- 要解合并

- f(0) == ""
- f(1) == (f(0))
- f(2) == (f(0))f(1) + (f(1))f(0)
- f(3) == (f(0))f(2) + (f(1))f(1) + (f(2))f(0)
- ...
- f(n) == ((f0))f(n-1) + (f(1))f(n-2) + (f(2))f(n-3) + ... +(f(i))f(n-i-1) + ... + (f(n-1))

---

- dp[i]的要点：
  - i 对括号的一个组合，在 i - 1 对括号的基础上得到，这是思考 “状态转移方程” 的基础；
  - i 对括号的一个组合，一定以左括号 "(" 开始，不一定以 ")" 结尾。为此，我们可以枚举新的右括号 ")" 可能所处的位置，得到所有的组合；
  - 枚举的方式就是**枚举左括号 "(" 和右括号 ")" 中间可能的合法的括号对数**，而剩下的合法的括号对数在与第一个左括号 "(" 配对的右括号 ")" 的后面，这就用到了以前的状态。
  - 状态转移方程是：`dp[i] = "(" + dp[可能的括号对数] + ")" + dp[剩下的括号对数]`
  - “可能的括号对数” 与 “剩下的括号对数” 之和得为 i - 1, 故 “可能的括号对数” j 可以从 0 开始，最多不能超过 i， 即 i - 1；“剩下的括号对数” + j = i - 1，故 “剩下的括号对数” = i - j - 1。
  - 整理状态方程为：`dp[i] = "(" + dp[j] + ")" + dp[i- j - 1] , j = 0, 1, ..., i - 1`




```js
// 动态规划
var generateParenthesis2 = function(n) {
  if(n === 0) return [];
  const dp = new Array(n+1).fill("").map(() => new Array())
  dp[0] = [""]

  console.log('dp:' ,  dp)

  for(let i=1; i<=n; i++) {
    let cur = []
    for(let j=0; j<i; j++) {
      let str1 = dp[j];
      let str2 = dp[i-j-1];
      
      for(let k1 in str1) {
        for(let k2 in str2) {
          cur.push("(" + str1[k1] + ")" + str2[k2])
        }
      }
    }
    dp[i] = cur;
  }

  return dp[dp.length - 1]
}

console.log(generateParenthesis2(3))
```

## 回溯解法
